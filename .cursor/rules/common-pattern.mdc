---
description: This rule defines recommended patterns and anti-patterns for NestJS development, focusing on proven architectural practices and common pitfalls to avoid. It encourages the use of design patterns such as dependency injection, repositories, unit of work, and CQRS for scalability and maintainability, while promoting DTOs, interceptors, pipes, and global exception filters as standard approaches. It also highlights critical anti-patterns like tight coupling, god classes, ignored errors, and hardcoded configuration, helping developers write clean, testable, and resilient code. Additionally, it provides guidance on state management and error handling to ensure consistency, reliability, and robustness across applications.
globs: *.ts
alwaysApply: true
---
- **Common Patterns and Anti-patterns:**
  - **Design Patterns:**
    - **Dependency Injection:** Use NestJS's built-in dependency injection container to manage dependencies and promote loose coupling.
    - **Repository Pattern:** Abstract data access logic into repositories to decouple services from specific database implementations.
    - **Unit of Work:**  Use a Unit of Work pattern for managing transactions across multiple repositories.
    - **CQRS (Command Query Responsibility Segregation):** For complex applications, consider using CQRS to separate read and write operations, improving performance and scalability.
  - **Recommended Approaches:**
    - Use DTOs (Data Transfer Objects) for data validation and transformation between layers.
    - Implement global exception filters to handle errors consistently across the application.
    - Use interceptors for logging, caching, and other cross-cutting concerns.
    - Utilize pipes for request validation and data transformation.
    - Use asynchronous operations (`async/await`) for non-blocking I/O operations.
  - **Anti-patterns:**
    - **Tight Coupling:** Avoid creating tightly coupled components that are difficult to test and maintain. Use dependency injection and interfaces to promote loose coupling.
    - **God Classes:** Avoid creating classes with too many responsibilities. Break down large classes into smaller, more manageable components.
    - **Ignoring Errors:** Always handle errors properly using try-catch blocks, exception filters, and logging. Never ignore errors or swallow exceptions.
    - **Hardcoding Configuration:** Avoid hardcoding configuration values directly in the code. Use environment variables or configuration files to manage settings.
  - **State Management:**
    - For simple applications, use services to manage application state.
    - For more complex applications, consider using a state management library like Redux or NgRx (although this is less common on the backend).
    - Avoid storing sensitive data in the client-side state. Store it securely on the server.
  - **Error Handling:**
    - Implement a global exception filter to catch unhandled exceptions and return appropriate error responses to the client.
    - Use custom exceptions to represent specific error conditions in the application.
    - Log errors with sufficient detail to facilitate debugging.
    - Return consistent error responses with appropriate HTTP status codes.
    