---
description: This rule provides guidance on performance optimization in NestJS applications, focusing on efficient resource usage and scalable design. It covers caching strategies, query optimization, and connection pooling to enhance responsiveness, as well as memory management techniques like streaming and object pooling to prevent leaks. It also highlights bundle size and lazy loading practices to reduce overhead and improve load times. Together, these recommendations ensure that applications remain performant, scalable, and resource-efficient.
globs: *.ts
alwaysApply: true
---
- **Performance Considerations:**
  - *Optimization Techniques:*
    - Use caching to reduce database load and improve response times.  NestJS provides built-in support for caching using interceptors.
    - Optimize database queries by using indexes, avoiding N+1 queries, and using efficient data retrieval methods.
    - Use connection pooling to reduce the overhead of establishing database connections.
    - Profile the application to identify performance bottlenecks and optimize accordingly.
  - *Memory Management:*
    - Avoid memory leaks by properly managing resources and releasing unused objects.
    - Use streams for handling large files or data streams.
    - Use object pooling to reuse frequently created objects.
  - *Rendering Optimization (Server-Side Rendering):*
    - Not directly applicable to NestJS, as it's primarily a backend framework. However, if using SSR, optimize rendering performance by caching rendered pages and using efficient templating engines.
  - *Bundle Size Optimization:*
    - Use tree shaking to remove unused code from the bundle.
    - Minify and compress code to reduce bundle size.
    - Use code splitting to load only the necessary code for each route or module.
  - *Lazy Loading:*
    - Use lazy loading to load modules or features on demand, improving initial load times.
    - Implement code splitting to create smaller bundles that can be loaded independently.
    