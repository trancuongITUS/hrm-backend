---
description: This rule establishes consistent coding conventions for NestJS projects, covering naming standards, code style, and best practices in TypeScript. It ensures that variables, classes, and functions follow a unified format, enforces readability and maintainability, and promotes clean, predictable code across the entire codebase.
globs: *.ts
alwaysApply: true
---
- **Coding Convention:**
  - *Basic Principles:*
    - Use English for all code and documentation.
    - Use strict TypeScript configuration.
    - Always declare the type of each variable and function (parameters and return value).
    - Avoid using `any`, prefer `unknown` for unknown types.
    - Create necessary types.
    - Leverage TypeScript's built-in utility types.
    - Use generics for reusable type patterns.
    - Use JSDoc to document public classes and methods.
    - Don't leave blank lines within a function.
    - Follow DRY principle, using utils function with repeat code.
    - One export per file.
  - *Naming Convention:*
    - Use descriptive and consistent naming conventions.  Prefix files based on their role (e.g., `user.controller.ts`, `auth.service.ts`, `create-user.dto.ts`).
    - Use PascalCase for classes, type names and interfaces (e.g., `UserService`, `CreateUserDto`).
    - Use camelCase for instances, functions and variables (e.g., `userService`, `createUserDto`).
    - Use kebab-case for file and directory names.
    - Use UPPER_CASE for constants.
    - Avoid magic numbers and define constants.
    - Start each function with a verb.
    - Use verbs for boolean variables. Example: isLoading, hasError, canDelete, etc.
    - Use complete words instead of abbreviations and correct spelling.
    - Except for standard abbreviations like API, URL, etc.
    - Except for well-known abbreviations:
      - i, j for loops
      - err for errors
      - ctx for contexts
      - req, res, next for middleware function parameters
  - *Code Organization:*
    - Encapsulate features within modules. Each module should represent a distinct part of the application and handle related functionality.
    - Modules should import necessary dependencies and export components that other modules need.
    - Use the `forRoot` and `forFeature` methods for configuration and feature modules, respectively, especially when dealing with database connections or other shared resources.
    - Follow the SOLID principles for designing components.  Each component (controller, service, etc.) should have a single responsibility.
    - Use dependency injection to manage dependencies between components, making them more testable and maintainable.
    - Controllers should handle request routing and validation, services should implement business logic, and entities should represent data models.
    - For large applications, consider splitting modules into smaller, more manageable chunks using feature modules or lazy-loaded modules.
    - Use dynamic imports and lazy loading to improve initial load times and reduce bundle size.
